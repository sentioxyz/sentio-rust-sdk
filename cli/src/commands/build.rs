use super::Command;
use crate::utils::{
    config::ConfigManager, tool_validator::ToolValidator, validator::ProjectValidator,
};
use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use std::path::{Path, PathBuf};
use tokio::process::Command as TokioCommand;

/// Build options for cross-compilation
#[derive(Debug, Clone)]
pub struct BuildOptions {
    pub skip_validation: bool,
    pub target: String,
    pub optimization_level: String,
    pub features: Vec<String>,
    pub verbose: bool,
}

impl Default for BuildOptions {
    fn default() -> Self {
        Self {
            skip_validation: false,
            target: "x86_64-unknown-linux-musl".to_string(),
            optimization_level: "release".to_string(),
            features: vec![],
            verbose: false,
        }
    }
}

/// Cross-compiler for building Rust processors
pub struct CrossCompiler {
    target: String,
}

impl CrossCompiler {
    pub fn new(target: String) -> Self {
        Self { target }
    }

    /// Check if the target is installed
    pub async fn check_target_installed(&self) -> Result<bool> {
        let output = TokioCommand::new("rustup")
            .args(&["target", "list", "--installed"])
            .output()
            .await
            .context("Failed to check installed targets")?;

        if !output.status.success() {
            return Err(anyhow!("Failed to list installed targets"));
        }

        let installed_targets =
            String::from_utf8(output.stdout).context("Failed to parse rustup output")?;

        Ok(installed_targets
            .lines()
            .any(|line| line.trim() == self.target))
    }

    /// Install the target if not already installed
    pub async fn ensure_target_installed(&self) -> Result<()> {
        if !self.check_target_installed().await? {
            println!("Installing target: {}", self.target);

            let status = TokioCommand::new("rustup")
                .args(&["target", "add", &self.target])
                .status()
                .await
                .context("Failed to install target")?;

            if !status.success() {
                return Err(anyhow!("Failed to install target: {}", self.target));
            }
        }
        Ok(())
    }

    /// Determine if we should use cross instead of cargo for compilation
    fn should_use_cross(&self) -> bool {
        let current_arch = std::env::consts::ARCH;
        let current_os = std::env::consts::OS;

        // Parse target triple
        let target_parts: Vec<&str> = self.target.split('-').collect();
        if target_parts.len() < 3 {
            return false; // Invalid target format, use cargo
        }

        let target_arch = target_parts[0];
        let target_os = if self.target.contains("linux") {
            "linux"
        } else if self.target.contains("darwin") || self.target.contains("apple") {
            "macos"
        } else if self.target.contains("windows") {
            "windows"
        } else {
            return false; // Unknown OS, use cargo
        };

        // Use cross if architecture or OS differs
        target_arch != current_arch || target_os != current_os
    }

    /// Ensure Cross.toml is configured with protoc installation
    async fn ensure_cross_toml_configured(
        &self,
        project_path: &Path,
        verbose: bool,
    ) -> Result<PathBuf> {
        let cross_toml_path = project_path.join("Cross.toml");

        // Generate Cross.toml content with protoc installation for the target
        let cross_toml_content = self.generate_cross_toml_content();

        // Write or update Cross.toml
        tokio::fs::write(&cross_toml_path, cross_toml_content)
            .await
            .context("Failed to write Cross.toml")?;

        if verbose {
            println!("Generated Cross.toml for target: {}", self.target);
        }

        Ok(cross_toml_path)
    }

    /// Generate Cross.toml content with protoc installation for the current target
    fn generate_cross_toml_content(&self) -> String {
        let protoc_install_commands = self.get_protoc_install_commands_for_target(&self.target);

        format!(
            r#"# Cross.toml configuration for cross-compilation
# Auto-generated by sentio build command

[build.env]
passthrough = [
    "RUST_LOG",
]

# Configuration for {}
[target.{}]
pre-build = [
{}
]
"#,
            self.target,
            self.target,
            protoc_install_commands
                .iter()
                .map(|cmd| format!("    \"{}\",", cmd))
                .collect::<Vec<_>>()
                .join("\n")
        )
    }

    /// Get protoc installation commands for the given target
    fn get_protoc_install_commands_for_target(&self, target: &str) -> Vec<String> {
        if target.contains("linux") {
            // Debian/Ubuntu-based containers (glibc) - download binary directly
            vec![
                "apt-get update".to_string(),
                "apt-get install -y curl unzip libssl-dev".to_string(),
                "mkdir -p /usr/local".to_string(),
                "curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v31.1/protoc-31.1-linux-x86_64.zip".to_string(),
                "unzip protoc-31.1-linux-x86_64.zip -d /usr/local".to_string(),
                "chmod +x /usr/local/bin/protoc".to_string(),
                "rm protoc-31.1-linux-x86_64.zip".to_string(),
                "protoc --version".to_string(),
            ]
        } else {
            // Default fallback for other targets
            vec!["echo 'protoc installation not configured for this target'".to_string()]
        }
    }

    /// Compile the project for the target
    pub async fn compile(&self, project_path: &Path, options: &BuildOptions) -> Result<PathBuf> {
        self.ensure_target_installed().await?;

        // Determine if we need cross-compilation
        let use_cross = self.should_use_cross();

        let mut cmd = if use_cross {
            println!("Using cross for cross-compilation");
            TokioCommand::new("cross")
        } else {
            TokioCommand::new("cargo")
        };

        cmd.arg("build")
            .arg("--target")
            .arg(&self.target)
            .current_dir(project_path);

        // If using cross, ensure Cross.toml is configured for protoc
        if use_cross {
            let mut cross_toml_path = self
                .ensure_cross_toml_configured(project_path, options.verbose)
                .await?;
            cross_toml_path = cross_toml_path.canonicalize()?;
            // Set CROSS_CONFIG environment variable to point to the Cross.toml file
            cmd.env("CROSS_CONFIG", &cross_toml_path);
            if options.verbose {
                println!("Set CROSS_CONFIG to: {}", cross_toml_path.display());
            }
        }

        // Add optimization level
        if options.optimization_level == "release" {
            cmd.arg("--release");
        }

        // Add features
        if !options.features.is_empty() {
            cmd.arg("--features").arg(options.features.join(","));
        }

        // Add verbose flag
        if options.verbose {
            cmd.arg("--verbose");
        }

        println!("Compiling for target: {}", self.target);
        let build_tool = if use_cross { "cross" } else { "cargo" };
        let status = cmd
            .status()
            .await
            .context(format!("Failed to execute {} build", build_tool))?;

        if !status.success() {
            return Err(anyhow!("Build failed"));
        }

        // Locate the built binary
        self.locate_binary(project_path, options).await
    }

    /// Locate the built binary
    pub async fn locate_binary(&self, project_path: &Path, options: &BuildOptions) -> Result<PathBuf> {
        // Check project-specific target directory first
        let project_target_dir = project_path.join("target");

        // Check if we're in a workspace by looking for a workspace root
        let workspace_root = Self::find_workspace_root(project_path);

        // Create list of potential target directories to check
        let mut potential_base_dirs = vec![project_target_dir];
        if let Some(workspace) = workspace_root {
            potential_base_dirs.push(workspace.join("target"));
        }

        // Check each potential location
        for base_target_dir in &potential_base_dirs {
            let target_dir = base_target_dir.join(&self.target);
            let profile_dir = if options.optimization_level == "release" {
                target_dir.join("release")
            } else {
                target_dir.join("debug")
            };

            // Check if binary exists in this location
            if let Ok(binary_path) = self
                .find_binary_in_directory(&profile_dir, project_path)
                .await
            {
                return Ok(binary_path);
            }
        }

        // If we get here, binary wasn't found in any expected location
        Err(anyhow!(
            "NEW: Binary not found in any expected target directory"
        ))
    }

    /// Find the binary in a specific directory
    async fn find_binary_in_directory(
        &self,
        profile_dir: &Path,
        project_path: &Path,
    ) -> Result<PathBuf> {
        // Read Cargo.toml to get the binary name
        let cargo_toml_path = project_path.join("Cargo.toml");
        let cargo_toml_content = tokio::fs::read_to_string(&cargo_toml_path)
            .await
            .context("Failed to read Cargo.toml")?;

        let cargo_toml: toml::Value =
            toml::from_str(&cargo_toml_content).context("Failed to parse Cargo.toml")?;

        let binary_name = if let Some(bin_section) = cargo_toml.get("bin") {
            if let Some(bins) = bin_section.as_array() {
                if let Some(first_bin) = bins.first() {
                    first_bin
                        .get("name")
                        .and_then(|n| n.as_str())
                        .unwrap_or("main")
                        .to_string()
                } else {
                    "main".to_string()
                }
            } else {
                "main".to_string()
            }
        } else if let Some(package) = cargo_toml.get("package") {
            package
                .get("name")
                .and_then(|n| n.as_str())
                .unwrap_or("main")
                .to_string()
        } else {
            "main".to_string()
        };

        let binary_path = profile_dir.join(&binary_name);

        if !binary_path.exists() {
            return Err(anyhow!(
                "Binary not found at expected location: {}",
                binary_path.display()
            ));
        }

        Ok(binary_path)
    }

    /// Find the workspace root by looking for Cargo.toml with [workspace] section
    fn find_workspace_root(start_path: &Path) -> Option<PathBuf> {
        let mut current = start_path
            .canonicalize()
            .unwrap_or_else(|_| start_path.to_path_buf());
        loop {
            let cargo_toml = current.join("Cargo.toml");
            if cargo_toml.exists() {
                if let Ok(content) = std::fs::read_to_string(&cargo_toml) {
                    if let Ok(toml_value) = toml::from_str::<toml::Value>(&content) {
                        if toml_value.get("workspace").is_some() {
                            return Some(current);
                        }
                    }
                }
            }

            if !current.pop() {
                break;
            }
        }

        None
    }
}

/// Binary locator and verifier
pub struct BinaryLocator;

impl BinaryLocator {
    /// Verify that a binary exists and is executable
    pub fn verify_binary(binary_path: &Path) -> Result<()> {
        if !binary_path.exists() {
            return Err(anyhow!("Binary does not exist: {}", binary_path.display()));
        }

        if !binary_path.is_file() {
            return Err(anyhow!("Path is not a file: {}", binary_path.display()));
        }

        // Check if file is executable (Unix-like systems)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata =
                std::fs::metadata(binary_path).context("Failed to read binary metadata")?;
            let permissions = metadata.permissions();

            if permissions.mode() & 0o111 == 0 {
                return Err(anyhow!(
                    "Binary is not executable: {}",
                    binary_path.display()
                ));
            }
        }

        Ok(())
    }

    /// Get binary size and other metadata
    pub fn get_binary_info(binary_path: &Path) -> Result<BinaryInfo> {
        let metadata = std::fs::metadata(binary_path).context("Failed to read binary metadata")?;

        Ok(BinaryInfo {
            path: binary_path.to_path_buf(),
            size: metadata.len(),
            modified: metadata.modified().ok(),
        })
    }
}

/// Binary information
#[derive(Debug)]
pub struct BinaryInfo {
    pub path: PathBuf,
    pub size: u64,
    pub modified: Option<std::time::SystemTime>,
}

impl std::fmt::Display for BinaryInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Binary: {} ({} bytes)", self.path.display(), self.size)?;
        if let Some(modified) = self.modified {
            if let Ok(duration) = modified.duration_since(std::time::UNIX_EPOCH) {
                write!(f, ", modified: {}", duration.as_secs())?;
            }
        }
        Ok(())
    }
}

pub struct BuildCommand {
    pub path: String,
    pub skip_validation: bool,
    pub target: Option<String>,
    pub optimization_level: Option<String>,
    pub features: Vec<String>,
    pub verbose: bool,
}

impl BuildCommand {
    /// Create a new build command with default options
    pub fn new(path: String) -> Self {
        Self {
            path,
            skip_validation: false,
            target: None,
            optimization_level: None,
            features: vec![],
            verbose: false,
        }
    }

    /// Build the processor with validation
    pub async fn build_processor(&self) -> Result<PathBuf> {
        let project_path = Path::new(&self.path);

        // Ensure we're in a valid project directory
        if !project_path.exists() {
            return Err(anyhow!("Project path does not exist: {}", self.path));
        }

        // Load configuration
        let mut config_manager = ConfigManager::new(project_path);
        config_manager
            .load()
            .context("Failed to load project configuration")?;

        let config = config_manager
            .get_effective_config()
            .context("Failed to get effective configuration")?;

        // Create build options from config and command arguments
        let build_options = BuildOptions {
            skip_validation: self.skip_validation,
            target: self.target.clone().unwrap_or(config.build.target),
            optimization_level: self
                .optimization_level
                .clone()
                .unwrap_or(config.build.optimization_level),
            features: if self.features.is_empty() {
                config.build.features
            } else {
                self.features.clone()
            },
            verbose: self.verbose,
        };

        // Validate project if not skipped
        if !build_options.skip_validation {
            println!("Validating project...");
            let validator = ProjectValidator::new();
            validator
                .validate_project(&self.path)
                .context("Project validation failed")?;
            println!("✓ Project validation passed");

            // Validate build tools
            println!("Validating build tools...");
            let tool_validator = ToolValidator::new();
            let tool_results = tool_validator
                .validate_tools_for_target(&build_options.target)
                .await
                .context("Failed to validate build tools")?;

            // Print tool validation results
            if !tool_results.issues.is_empty() {
                for issue in &tool_results.issues {
                    println!("{}", issue);
                }
            }

            // Stop build if there are critical tool errors
            if tool_results.has_errors() {
                return Err(anyhow!(
                    "Build tools validation failed with {} error(s). Please install missing tools before continuing.",
                    tool_results.error_count()
                ));
            }

            if tool_results.has_warnings() {
                println!(
                    "⚠️  Build tools validation completed with {} warning(s), but continuing...",
                    tool_results.warning_count()
                );
            } else {
                println!("✓ Build tools validation passed");
            }
        }

        // Perform cross-compilation
        let compiler = CrossCompiler::new(build_options.target.clone());
        let binary_path = compiler
            .compile(project_path, &build_options)
            .await
            .context("Cross-compilation failed")?;

        // Verify the binary
        BinaryLocator::verify_binary(&binary_path).context("Binary verification failed")?;

        let binary_info = BinaryLocator::get_binary_info(&binary_path)
            .context("Failed to get binary information")?;

        println!("✓ Build completed successfully");
        println!("  {}", binary_info);

        Ok(binary_path)
    }
}

#[async_trait]
impl Command for BuildCommand {
    async fn execute(&self) -> Result<()> {
        match self.build_processor().await {
            Ok(binary_path) => {
                println!("Binary location: {}", binary_path.display());
                Ok(())
            }
            Err(e) => {
                eprintln!("Build failed: {}", e);
                Err(e)
            }
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    fn create_test_project(temp_dir: &TempDir) -> Result<()> {
        let project_path = temp_dir.path();

        // Create Cargo.toml
        let cargo_toml = r#"
[package]
name = "test-processor"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "test-processor"
path = "src/main.rs"

[dependencies]
sentio-sdk = "0.1.0"
"#;
        fs::write(project_path.join("Cargo.toml"), cargo_toml)?;

        // Create src directory and main.rs
        fs::create_dir_all(project_path.join("src"))?;
        fs::write(
            project_path.join("src/main.rs"),
            r#"
fn main() {
    println!("Hello, Sentio!");
}
"#,
        )?;

        // Create sentio.yaml
        let sentio_config = r#"
name: test-processor
version: 0.1.0
target_network: ethereum
contracts: []
build:
  target: x86_64-unknown-linux-musl
  optimization_level: release
  features: []
"#;
        fs::write(project_path.join("sentio.yaml"), sentio_config)?;

        Ok(())
    }

    #[test]
    fn test_build_options_default() {
        let options = BuildOptions::default();
        assert!(!options.skip_validation);
        assert_eq!(options.target, "x86_64-unknown-linux-musl");
        assert_eq!(options.optimization_level, "release");
        assert!(options.features.is_empty());
        assert!(!options.verbose);
    }

    #[test]
    fn test_build_command_new() {
        let command = BuildCommand::new("./test".to_string());
        assert_eq!(command.path, "./test");
        assert!(!command.skip_validation);
        assert!(command.target.is_none());
        assert!(command.optimization_level.is_none());
        assert!(command.features.is_empty());
        assert!(!command.verbose);
    }

    #[test]
    fn test_cross_compiler_new() {
        let compiler = CrossCompiler::new("x86_64-unknown-linux-musl".to_string());
        assert_eq!(compiler.target, "x86_64-unknown-linux-musl");
    }

    #[tokio::test]
    async fn test_cross_compiler_check_target_installed() {
        let compiler = CrossCompiler::new("x86_64-unknown-linux-musl".to_string());

        // This test might fail in CI environments without rustup
        // In a real scenario, you'd mock the command execution
        match compiler.check_target_installed().await {
            Ok(_) => {
                // Test passed - target check worked
            }
            Err(_) => {
                // Test environment doesn't have rustup, which is acceptable
                println!("Skipping target check test - rustup not available");
            }
        }
    }

    #[test]
    fn test_binary_info_display() {
        let binary_info = BinaryInfo {
            path: PathBuf::from("/path/to/binary"),
            size: 1024,
            modified: None,
        };

        let display = format!("{}", binary_info);
        assert!(display.contains("/path/to/binary"));
        assert!(display.contains("1024 bytes"));
    }

    #[test]
    fn test_binary_locator_verify_nonexistent() {
        let result = BinaryLocator::verify_binary(Path::new("/nonexistent/path"));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("does not exist"));
    }

    #[test]
    fn test_binary_locator_get_info_nonexistent() {
        let result = BinaryLocator::get_binary_info(Path::new("/nonexistent/path"));
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_build_command_nonexistent_path() {
        let command = BuildCommand::new("/nonexistent/path".to_string());
        let result = command.build_processor().await;
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("does not exist"));
    }

    #[tokio::test]
    async fn test_build_command_with_validation_skip() {
        let temp_dir = TempDir::new().unwrap();
        create_test_project(&temp_dir).unwrap();

        let mut command = BuildCommand::new(temp_dir.path().to_str().unwrap().to_string());
        command.skip_validation = true;

        // This test will likely fail because we don't have a real Rust project
        // that can be compiled, but it tests the validation skip logic
        let result = command.build_processor().await;

        // We expect this to fail at compilation, not validation
        if let Err(e) = result {
            let error_msg = e.to_string();
            // Should not contain validation errors since we skipped validation
            assert!(!error_msg.contains("validation failed"));
        }
    }

    #[test]
    fn test_build_options_with_features() {
        let options = BuildOptions {
            skip_validation: true,
            target: "aarch64-unknown-linux-gnu".to_string(),
            optimization_level: "debug".to_string(),
            features: vec!["feature1".to_string(), "feature2".to_string()],
            verbose: true,
        };

        assert!(options.skip_validation);
        assert_eq!(options.target, "aarch64-unknown-linux-gnu");
        assert_eq!(options.optimization_level, "debug");
        assert_eq!(options.features.len(), 2);
        assert!(options.verbose);
    }

    #[tokio::test]
    async fn test_cross_compiler_locate_binary_missing_cargo_toml() {
        let temp_dir = TempDir::new().unwrap();
        let compiler = CrossCompiler::new("x86_64-unknown-linux-musl".to_string());
        let options = BuildOptions::default();

        let result = compiler.locate_binary(temp_dir.path(), &options).await;
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Failed to read Cargo.toml"));
    }

    #[tokio::test]
    async fn test_cross_compiler_locate_binary_invalid_cargo_toml() {
        let temp_dir = TempDir::new().unwrap();

        // Create invalid Cargo.toml
        fs::write(temp_dir.path().join("Cargo.toml"), "invalid toml content").unwrap();

        let compiler = CrossCompiler::new("x86_64-unknown-linux-musl".to_string());
        let options = BuildOptions::default();

        let result = compiler.locate_binary(temp_dir.path(), &options).await;
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Failed to parse Cargo.toml"));
    }

    #[tokio::test]
    async fn test_cross_compiler_locate_binary_with_valid_cargo_toml() {
        let temp_dir = TempDir::new().unwrap();

        // Create valid Cargo.toml
        let cargo_toml = r#"
[package]
name = "test-binary"
version = "0.1.0"

[[bin]]
name = "custom-binary"
path = "src/main.rs"
"#;
        fs::write(temp_dir.path().join("Cargo.toml"), cargo_toml).unwrap();

        let compiler = CrossCompiler::new("x86_64-unknown-linux-musl".to_string());
        let options = BuildOptions::default();

        let result = compiler.locate_binary(temp_dir.path(), &options).await;
        // This will fail because the binary doesn't exist, but it should parse the Cargo.toml correctly
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Binary not found"));
    }

    #[test]
    fn test_build_command_execute_error_handling() {
        let command = BuildCommand::new("/nonexistent".to_string());

        // Test that execute properly handles and formats errors
        tokio::runtime::Runtime::new().unwrap().block_on(async {
            let result = command.execute().await;
            assert!(result.is_err());
        });
    }
}
